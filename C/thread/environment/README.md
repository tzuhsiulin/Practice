程式啟動和退出
================

如果要撰寫一個品質高的程式就必須了解程式執行的內部機制。因此首先必須了解程式啟動和退出的內部機制的基礎，以下將討論 Linux Shell 中啟動一個程式的方法和過程，及程式由外部儲存載入到記憶體中的過程，和程式退出時所做的操作。

## 載入程式流程 ##
- 從目的檔案中讀取足夠的頁首資訊，找出需要多少位址空間
-  分配位址空間，如果目標程式碼的格式具有獨立的段，那麼就將位址空間按獨立的段劃分
- 將程式讀入位址空間的段中
- 將程式末尾的 bass 段空間填充為 0 ，如果虛擬記憶體系統不自動這麼做時
- 如果體系結構需要，建立一個 Stack 段
- 設定諸如程式參數和環境變數的其他執行時資訊
- 開始執行程式，從 main 函數的位址初開始循序執行程式


## 載入地址 ##
由此可知，由於載入器每次將程式載入前需要分配位址空間，所以每次程式載入時不會使用相同的記憶體位址。範例程式如下：
```
#include <stdio.h>

int main() {
	int a;
	int b;

	printf("the first address : %x\n", &a);
	printf("the second address : %x\n", &b);

	return 0;
}
```

## 退出程式 ##
在 Linux 環境下，一個執行緒有三種退出的方式：

 - 執行緒自願退出
	 在 C 語言原始程式碼中表現為 return 敘述和 exit 函式呼叫。在執行緒退出時，需要回收執行緒所分配的資源，例如，執行緒的位址空間，檔案描述符等。在回收資源的同時，作業系統也對每一項資源進行善後的處理，例如，對於開啟的檔案，在釋放描述符的同時，還要將緩衝區中的內容沖洗到外部儲存上，保證檔案緩衝區的內容和外部儲存中的內容一致。
	 
 - 執行緒收到一個訊號退出
	 這種情況很常見，往往出現父執行緒對子執行緒的操作上。例如，在 shell 中執行一個程式，如果不想讓其執行，則會使用 “ctrl + c“ 組合鍵終止此程式，而子執行緒在收到訊號後，也會像自願退出時一樣，處理分配的資源，並且正常退出。
	 
 - 執行緒執行一個導致例外的操作後退出
	 這種情況是在程式沒有準備的情況下退出的。這時候作業系統也會對其資源進行回收，但是有可能不會對這些資源做善後的處理，這樣的情況稱為例外退出，發出訊號的通常是作業系統本身。

##執行緒終止處理函數##
在 Linux 中，系統允許在執行緒退出的時候呼叫一些使用者自己定義的函數，這些函數成為終止處理函數。 Linux 規定最多可以設定 32個這樣的執行緒終止處理函數。其函數原型如下：
```
#include<stdlib.h>

int atexit(void (* function)(void));
```

其使用方式如下：
```
#include <stdio.h>
#include <stdlib.h>

void f1(void) {
	printf("the first exit handler\n");
}

void f2(void) {
	printf("this secod exit handler\n");
}

int main(void) {
	if (atexit(f1) == -1) {
		perror("fail to set exit handler");
		exit(1);
	}

	if (atexit(f1) == -1) {
		perror("fail to set exit handler");
		exit(1);
	}

	if (atexit(f2) == -1) {
		perror("fail to set exit handler");
		exit(1);
	}

	return 0;
}
```